<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Apollo + React</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link
      rel="stylesheet"
      href="dist/theme/apollo.css"
    />

    <!-- Theme used for syntax highlighted code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/atom-one-dark.css"
    />
    <!-- <link rel="stylesheet" href="plugin/highlight/hybrid.css" /> -->

    <style>
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }

        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section
          data-background-image="https://d33wubrfki0l68.cloudfront.net/79880a56361cfde4c79207d6988a63495a3c1110/953fa/static/home-hero-ec83eaa910bbb42b62391e145e6c9a5f.png"
        >
          <h1 style="margin-bottom: 0">Apollo</h1>

          <p
            style="
              margin-top: 0;
              margin-bottom: calc(
                var(--r-block-margin) * 2
              );
              opacity: 0.6;
            "
          >
            Basics and Conventions
          </p>
          <div
            style="
              display: flex;
              justify-content: center;
            "
          >
            <svg
              width="100px"
              height="100px"
              viewBox="0 0 240 240"
              version="1.1"
              xmlns="http://www.w3.org/2000/svg"
              xmlns:xlink="http://www.w3.org/1999/xlink"
            >
              <g
                transform="translate(20.000000, 20.000000)"
                fill-rule="nonzero"
              >
                <polygon
                  fill="white"
                  points="112.4 48.7 88.2 48.7 53.2 139.6 75.1 139.6 80.8 124.2 113.9 124.2 107.9 107.2 86.1 107.2 100.3 68.1 125.5 139.6 147.4 139.6"
                ></polygon>
                <path
                  id="logo-spin"
                  fill="white"
                  d="M196.3,73 C196.2,72.7 196.2,72.4 196,72.1 C196,72 195.9,71.8 195.9,71.8 C195.1,70.1 193.4,68.9 191.4,68.9 C188.6,68.9 186.4,71.1 186.4,73.9 C186.4,74.5 186.5,75 186.7,75.5 L186.7,75.5 C188.9,83.4 190,91.6 190,100 C190,124 180.6,146.6 163.6,163.6 C146.6,180.6 124,190 100,190 C76,190 53.4,180.6 36.4,163.6 C19.4,146.6 10,124 10,100 C10,76 19.4,53.4 36.4,36.4 C53.4,19.4 76,10 100,10 C121.5,10 141.8,17.5 158,31.2 C157.5,32.6 157.2,34.1 157.2,35.7 C157.2,42.5 162.7,47.9 169.4,47.9 C176.2,47.9 181.6,42.4 181.6,35.7 C181.6,29 176.1,23.5 169.4,23.5 C167.9,23.5 166.5,23.8 165.2,24.2 C147.7,9.1 124.9,0 100,0 C44.8,0 0,44.8 0,100 C0,155.2 44.8,200 100,200 C155.2,200 200,155.2 200,100 C200,90.7 198.7,81.6 196.3,73 Z"
                  style="
                    transform-origin: 100px 100px;
                    animation: 2s
                      cubic-bezier(0.75, 0, 0.25, 1) 0s
                      infinite normal none running spin;
                  "
                ></path>
              </g>
              <rect
                fill="transparent"
                x="0"
                y="0"
                width="240"
                height="240"
              ></rect>
            </svg>
          </div>
        </section>

        <section data-markdown="agenda.md"></section>

        <section>
          <h2 data-id="code-title">
            Basic Query Operation
          </h2>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|3|4|5|6|14|12-13|16|"><script type="text/template">
						import { gql, useQuery } from "@apollo/client"

						const Query = gql`
							query User {
								viewer {
									login
								}
							}
						`

						function Nav() {
							const {
								data: { viewer },
							} = useQuery(Query)

							return <nav>Hello ${viewer.login}</nav>
						}

					</script></code></pre>

          <aside class="notes">
            Quick recap of queries
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">
            Query Operations
          </h2>
          <p class="subtitle">Variables</p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|4|5|17|"><script type="text/template">
						import { gql, useQuery } from "@apollo/client"

						const Query = gql`
							query Repo($owner: String!, $name: String) {
								repository(owner: $owner, name: $name) {
									name
									url
								}
							}
						`

						function Repo({ owner, name }) {
							const {
								data: {
									repository,
								},
							} = useQuery(Query, { variables: { owner, name } })

							return (
								<div>
									{repository.name}
									{repository.url}
								</div>
							)
						}

					</script></code></pre>

          <aside class="notes">
            Quick recap of variables - must start with
            dollar sign
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">
            Query Operations
          </h2>
          <p class="subtitle">State</p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|12-15"><script type="text/template">
						import { gql, useQuery } from "@apollo/client"

						const Query = gql`
							query User {
								viewer {
									login
								}
							}
						`

						function Nav() {
							const { loading, error, data } = useQuery(Query)

							if (loading) return "Loading…"
							if (error) return "Failed to load"

							return <nav>Hello ${data.viewer.login}</nav>
						}

					</script></code></pre>

          <aside class="notes">
            Quick recap of state
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">
            Query Operations
          </h2>
          <p class="subtitle">State Helpers</p>
          <pre><code class="hljs jsx" data-trim><script type="text/template">
					// api/graph/helpers.js

					const queryResultToStatus = ({
						loading,
						error,
						called,
						data,
					}) => {
						if (!called) return QueryStatus.Idle
						if (loading) return QueryStatus.Loading
						if (error) return QueryStatus.Error
						if (data) return QueryStatus.Success
						throw new Error(
							"Apollo query resulted in an unexpected state: ",
							{
								called,
								loading,
								error,
								data,
							}
						)
					}
					</script></code></pre>

          <aside class="notes">
            This is available - use it!
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Exercise time!
						Write a query <!-- .element: class="subtitle" -->

						Display the current user’s list of open pull requests.

						**Branch: `1-write-a-query-template`**

						----
						*Hint: Use the `viewer` field to access queries for the current user* <!-- .element: class="hint" -->

						Note:
						- Introduce Apollo Studio
						- Show the desired end result in the app
						- Apollo Studio query: MyOpenPullRequests

					</textarea
          >
        </section>

        <section>
          <h2 data-id="code-title">
            Basic Mutation Operation
          </h2>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|4|5-8|14|23|"><script type="text/template">
					import { gql, useMutation } from "@apollo/client"

					const StarRepoMutation = gql`
						mutation StarRepo($id: ID!) { 
							addStar(input: {starrableId: $id}) {
								starrable {
									stargazerCount
								}
							}
						}
					`

					function StarButton({ id }) {
						const [addStar, result] = useMutation(StarRepoMutation)
						const status = queryResultToStatus(result)

						if (status === QueryStatus.Loading) return "Loading…"
						if (status === QueryStatus.Error)
							return "Failed to load"

						return (
							<button
								onClick={() => addStar({ variables: { id } })}
							>
								⭐️
							</button>
						)
					}
					</script></code></pre>

          <aside class="notes">
            - Difference between useQuery and
            useMutation - Lazy execution of mutations -
            How to pass variables - How the cache is
            updated and why this won't display the most
            recent result
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">
            Anatomy of a GraphQL document
          </h2>
          <p class="subtitle">
            Defines one or more operations and
            fragments.
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs graphql" data-trim data-line-numbers=""><script type="text/template">
					{
						rateLimit {
							limit
							nodeCount
							remaining
						}
					}

					# or

					query {
						rateLimit {
							limit
							nodeCount
							remaining
						}
					}
				</script></code></pre>

          <aside class="notes">
            - The document is what is sent to the
            server - The default operation is a query
            (without the query keyword) - Only a single
            unnamed operation can be sent in a document
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">
            Anatomy of a GraphQL document
          </h2>
          <p class="subtitle">
            Defines one or more operations and
            fragments.
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs graphql" data-trim data-line-numbers=""><script type="text/template">
					query One {
						viewer {
							login
						}
						rateLimit {
							limit
							nodeCount
							remaining
						}
					}

					query Two {
						repository(owner: "apollographql", name: "apollo-client") {
							stargazers {
								totalCount
							}
						}
					}

					mutation StarRepo($id: ID!) { 
						addStar(input: {starrableId: $id}) {
							starrable {
								stargazerCount
							}
						}
					}
				</script></code></pre>

          <aside class="notes">
            - The document can contain multiple
            operations or fragments (query, mutation or
            subscription) - They must be named - The
            result is always a single object with the
            name of the operation as the key
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Exercise time!
						Write a mutation <!-- .element: class="subtitle" -->

						Convert a PR to a draft.
						* it should be marked as a draft **and**
						* the title should be prefixed with "I'M NOT DONE WITH THIS!"

						**Branch: `2-write-a-mutation-template`**

						Note:
						- Show the desired result in the app
						- Show how to create a PR from Apollo Studio
						- Apollo Studio Query: ConvertPullRequestToDraf
					</textarea
          >
        </section>

        <section>
          <h2 data-id="code-title">
            Interfaces and Unions
          </h2>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|6-12|"><script type="text/template">
						import { gql, useMutation } from "@apollo/client"

						const StarRepoMutation = gql`
							mutation StarRepo($id: ID!) {
								addStar(input: { starrableId: $id }) {
									starrable {
										id
										stargazerCount
										... on Repository {
											homepageUrl
										}
									}
								}
							}
						`
						
						function StarButton({ id }) {
							const [addStar, result] = useMutation(StarRepoMutation)
							const status = queryResultToStatus(result)
						
							if (status === QueryStatus.Loading) return "Loading…"
							if (status === QueryStatus.Error)
								return "Failed to load"
						
							return (
								<button
									onClick={() => addStar({ variables: { id } })}
								>
									⭐️
								</button>
							)
						}
						
					</script></code></pre>

          <aside class="notes">
            - Interfaces are a way to describe the
            shape of a type - The implementing type
            must also include those fields - Showcase
            types in GraphQL schema - Apollo Studio
            Query: StarRepo
          </aside>
        </section>

        <section>
          <h2 data-id="code-title">Fragments</h2>
          <p class="subtitle">
            Share fields between operations
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|4-8|17|14|28|24|"><script type="text/template">
					import { gql, useQuery } from "@apollo/client"
					
					const ProfileFragment = gql`
						fragment Profile on User {
							id
							login
							avatarUrl
						}
					`
					
					const CurrentUserQuery = gql`
						query CurrentUser {
							viewer {
								...Profile
							}
						}
						${ProfileFragment}
					`
						
					const RepoOwnerQuery = gql`
						query Owner($name: String!, $owner: String!) {
							repository(name: $name, owner: $owner) {
								owner {
									...Profile
								}
							}
						}
						${ProfileFragment}
					`
				</script></code></pre>

          <aside class="notes">
            - Fragments are used to share fields
            between operations - They can also be
            defined on interfaces - showcase in AS -
            Apollo Studio Query: CurrentUser
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
					## Caching
					Apollo Normalized Cache <!-- .element: class="subtitle" -->
					- Responses are stored in a *local*, *normalized*, *in-memory* cache
					- Objects are identified by their `__typename` and `id` fields 

						(e.g. `Person:12345`)
					- Objects are stored in a *flat lookup table*

					Note:
					Showcase DevTools in OneRead
				</textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
					## Caching
					Cache Reads <!-- .element: class="subtitle" -->
					- If *all* requested data is present in the cache, that data is returned
					- This includes references to other objects
					- Otherwise, the request is sent to the server

					[Fetch Policies](https://www.apollographql.com/docs/react/data/queries/#setting-a-fetch-policy)

					Note:
					Describe different fetch policies and the default
				</textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
					## Caching
					Cache Writes <!-- .element: class="subtitle" -->
					- Objects in the cache are merged with new data.
					- For shared fields, the new object overwrites the cached values for those fields.
					- Other fields are preserved.
				</textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
					## Quiz Time!
				</textarea
          >
        </section>

        <section data-auto-animate="">
          <p class="subtitle">
            Given the two queries below, what will be
            stored in the cache?
          </p>

          <pre
            data-id="code-animation"
            style="font-size: 0.26em"
          ><code class="hljs jsx" data-trim><script type="text/template">
						import { gql, useQuery } from "@apollo/client"

						const RepoQuery = gql`
							query Repo($name: String!, $owner: String!) {
								repository(name: $name, owner: $owner) {
									id
									url
									owner {
										... on Organization {
											id
											name
										}
									}
								}
							}
						`

						const OrgQuery = gql`
							query Org($login: String!) {
								organization(login: $login) {
									id
									name
									url
									avatarUrl
							}
						`
						
						function Component({ id }) {
							useQuery(RepoQuery, { variables: {name: "apollo", owner: "apollographql"}})
							useQuery(OrgQuery, { variables: {login: "apollographql"}})
						
							// ...
						}
						
				</script></code></pre>
        </section>

        <section data-auto-animate="">
          <p class="subtitle">
            Given the two queries below, what will be
            stored in the cache?
          </p>
          <div
            style="display: flex; flex-direction: row"
          >
            <pre
              data-id="code-animation"
              style="font-size: 0.26em"
            ><code class="hljs jsx" data-trim><script type="text/template">
							import { gql, useQuery } from "@apollo/client"

							const RepoQuery = gql`
								query Repo($name: String!, $owner: String!) {
									repository(name: $name, owner: $owner) {
										id
										url
										owner {
											... on Organization {
												id
												name
											}
										}
									}
								}
							`
	
							const OrgQuery = gql`
								query Org($login: String!) {
									organization(login: $login) {
										id
										name
										url
										avatarUrl
								}
							`
							
							function Component({ id }) {
								useQuery(RepoQuery, { variables: {name: "apollo", owner: "apollographql"}})
								useQuery(OrgQuery, { variables: {login: "apollographql"}})
							
								// ...
							}
				</script></code></pre>
            <pre
              data-id="code-animation"
              style="
                max-width: 350px;
                padding-left: 8px;
                font-size: 0.26em;
              "
            ><code class="hljs jsx" data-trim><script type="text/template">
				{
					"Repository:1": {
						"__typename": "Repository",
						"id": 1,
						"url": "https://github.com/apollographql/apollo-client",
						"owner": {
							"__ref": "Organization:1",
						}
					},
					"Organization:1": {
						"__typename": "Organization",
						"id: 1",
						"name": "apollographql",
						"url": "https://github.com/apollographql",
						"avatarUrl": "https://avatars.githubusercontent.com/u/17189275?s=200&v=4"
					}
				}
				</script></code></pre>
          </div>
        </section>

        <section data-auto-animate="">
          <p class="subtitle">
            Will the second query's result be read from
            the cache or requested over the network?
          </p>

          <pre
            data-id="code-animation"
            style="font-size: 0.26em"
          ><code class="hljs jsx" data-trim><script type="text/template">
						import { gql, useQuery } from "@apollo/client"

						const RepoQuery = gql`
							query Repo($name: String!, $owner: String!) {
								repository(name: $name, owner: $owner) {
									id
									url
									owner {
										... on Organization {
											id
											name
										}
									}
								}
							}
						`

						const OrgQuery = gql`
							query Org($login: String!) {
								organization(login: $login) {
									id
									name
									url
									avatarUrl
							}
						`
						
						function Component({ id }) {
							useQuery(RepoQuery, { variables: {name: "apollo", owner: "apollographql"}})
							useQuery(OrgQuery, { variables: {login: "apollographql"}})
						
							// ...
						}
				</script></code></pre>
        </section>

        <section data-auto-animate>
          <p class="subtitle" style="font-size: 0.6em">
            What will be stored in the cache after the
            user clicks the button?
          </p>
          <img
            src="dist/assets/stars.png"
            height="30px"
            style="margin: 0"
          />

          <pre
            data-id="code-animation"
            style="font-size: 0.26em"
          ><code class="hljs jsx" data-trim><script type="text/template">
						import { gql, useQuery } from "@apollo/client"

						const RepoQuery = gql`
							query Repo($name: String!, $owner: String!) {
								repository(name: $name, owner: $owner) {
									id
									stargazerCount
								}
							}
						`

						const StarRepoMutation = gql`
							mutation StarRepo($id: ID!) {
								addStar(input: { starrableId: $id }) {
									starrable {
										... on Repository {
											homepageUrl
											stargazerCount
										}
									}
								}
							}
						`
						
						function StarButton() {
							const {data, loading, error} = useQuery(RepoQuery, { variables: {name: "apollo", owner: "apollographql"}})
							const [addStar, result] = useMutation(StarRepoMutation)

							if (loading) return "Loading…"
							if (error) return "Failed to load"

							return (
								<button
									onClick={() => addStar({ variables: { id: data.repository.id } })}
								>
									⭐️
								</button>
							)
						}		
						</script></code></pre>
        </section>

        <section data-auto-animate>
          <p class="subtitle" style="font-size: 0.6em">
            What will be stored in the cache after the
            user clicks the button?
          </p>
          <img
            src="dist/assets/stars.png"
            height="30px"
            style="margin: 0"
          />
          <div
            style="display: flex; flex-direction: row"
          >
            <pre
              data-id="code-animation"
              style="font-size: 0.26em"
            ><code class="hljs jsx" data-trim><script type="text/template">
						import { gql, useQuery } from "@apollo/client"

						const RepoQuery = gql`
							query Repo($name: String!, $owner: String!) {
								repository(name: $name, owner: $owner) {
									id
									stargazerCount
								}
							}
						`

						const StarRepoMutation = gql`
							mutation StarRepo($id: ID!) {
								addStar(input: { starrableId: $id }) {
									starrable {
										... on Repository {
											homepageUrl
											stargazerCount
										}
									}
								}
							}
						`
						
						function StarButton() {
							const {data, loading, error} = useQuery(RepoQuery, { variables: {name: "apollo", owner: "apollographql"}})
							const [addStar, result] = useMutation(StarRepoMutation)

							if (loading) return "Loading…"
							if (error) return "Failed to load"

							return (
								<button
									onClick={() => addStar({ variables: { id: data.repository.id } })}
								>
									⭐️
								</button>
							)
						}		
						</script></code></pre>
            <pre
              data-id="code-animation"
              style="
                max-width: 350px;
                padding-left: 8px;
                font-size: 0.26em;
              "
            ><code class="hljs jsx" data-trim><script type="text/template">
						{
							"Repository:1": {
								"id": 1,
								"stargazerCount": 0
							}
						}
						</script></code></pre>
          </div>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Field Policies
						* customize the way data is cached
						* customize the way data is read and written to the cache

						[API Reference](https://www.apollographql.com/docs/react/caching/cache-field-behavior#fieldpolicy-api-reference)

						Note:
						the field policy API provides a lot of tools to interact directly with the cache
					</textarea
          >
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Field Policies</h2>
          <p class="subtitle">
            Transform response fields
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|2|3-4|5|5-9|10-12|"><script type="text/template">
					const cache = new InMemoryCache({
						typePolicies: {
							User: {
								fields: {
									firstName: {
										read(value) {
											return value.toUpper()
										}
									},
									dateOfBirth(value) {
										return parseISO(value)
									},
								},
							},
						},
					});
				</script></code></pre>

          <aside class="notes">
            - read is called whenever the field is read
            from the cache - shortcut when not defining
            anything else but the read function - the
            returned value will always be returned from
            requests regardless of fetch policy
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Field Policies</h2>
          <p class="subtitle">
            Calculate client-side data
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|5-10|22|"><script type="text/template">
					const cache = new InMemoryCache({
						typePolicies: {
							User: {
								fields: {
									age(_, { readField }) {
										return differenceInYears(
											new Date(),
											readField("dateOfBirth")
										)
									}
								},
							},
						},
					});

					// later in query
					const Query = gql`
						query User {
							viewer {
								login
								dateOfBirth
								age @client
							}
						}
					`
				</script></code></pre>

          <aside class="notes">
            - readField can be used to read fields from
            the cache that belong to the same parent
            object (the user in this case)
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Exercise time!
						Write a field policy <!-- .element: class="subtitle" -->

						Compute the complexity score for your PRs.

						**Branch: `3-write-a-field-policy-template`**

						----
						My score "formula" <!-- .element: class="hint" -->
						```js
Math.floor(
	Math.abs(additions - deletions) / 100 +
		Math.pow(changedFiles, 2) / 100
)
						```
					</textarea
          >
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Field Policies</h2>
          <p class="subtitle">Update cache data</p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|5-10"><script type="text/template">
					const cache = new InMemoryCache({
						typePolicies: {
							User: {
								fields: {
									pullRequests: {
										merge(existing = [], incoming) {
											return [...existing, ...incoming];
										},
									},
								},
							},
						},
					});
				</script></code></pre>

          <aside class="notes">
            - merge is called whenever a field is
            updated in the cache - you can decide what
            ends up written to the cache based on the
            previous and new value
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Pagination</h2>
          <p class="subtitle">
            <code>fetchMore</code>
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|4|7-8|20-25|33-36|46-48|40-42|"><script type="text/template">
						import { gql, useQuery } from "@apollo/client"

						const OpenPullRequestsQuery = gql`
							query MyPullRequests($first: Int, $after: String) {
								viewer {
									pullRequests(
										first: $first, 
										after: $after, 
										states: [OPEN], 
										orderBy: { field: CREATED_AT, direction: DESC }) {
										edges {
											cursor # cursor for this node
											node {
												id
												title
												url
											}
										}

										pageInfo {
											hasNextPage
											hasPreviousPage
											startCursor # cursor for the first item in the page
											endCursor # cursor for the last item in the page
										}
								}
							}
						`

						const PAGE_SIZE = 10

						function Pagination() {
							const { data, fetchMore } = useQuery(
								OpenPullRequestsQuery,
								{ variables: { first: PAGE_SIZE } }
							)
							
							const pageInfo = data.viewer.pageInfo

							const onLoad = (cursor) => {
								fetchMore({ after: pageInfo.endCursor })
							}

							return (
								<div>
									{pageInfo.hasNextPage && (
										<button onClick={onLoad}>Next</button>
									)}
								</div>
							)
						}
				</script></code></pre>

          <aside class="notes">
            - when calling fetchMore you can provide
            new variables for the query - Apollo
            reexecutes this query
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Exercise time!
						Paginate results <!-- .element: class="subtitle" -->

						Fetch the next page of PRs when clicking "Load More".

						**Branch: `4-paginate-results-template`**

						Note:
						Let me know once the request is sent - is it updating the list?

						- since queries are cached with all their arguments, this is just saved as a separate result in the cache
						- it doesn't append to the previous query's result
						- we need to write a field policy that will merge the results
						- we could use the previous merge example
					</textarea
          >
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Pagination</h2>
          <p class="subtitle">
            <code>relayStylePagination</code>
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers=""><script type="text/template">
						const cache = new InMemoryCache({
							typePolicies: {
								User: {
									fields: {
										pullRequests: relayStylePagination()
									}
								}
							}
						})
				</script></code></pre>

          <aside class="notes">
            but Apollo provides us with a built-in
            policy for cursor pagination
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Exercise time!
						Paginate results <!-- .element: class="subtitle" -->

						Display all loaded PR pages.

						**Branch: `4-paginate-results-checkpoint-a`**

						Note:
						Why is this broken now?

						- by default the relay style pagination assumes all query arguments are pagination arguments
						- enter keyArgs
					</textarea
          >
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Field Policies</h2>
          <p class="subtitle">
            Customize caching behavior
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|6|15-19|"><script type="text/template">
						const cache = new InMemoryCache({
							typePolicies: {
								User: {
									fields: {
										pullRequests: {
											keyArgs: ["state"],
										},
									},
								},
							},
						})
						
						// later in query
						const Query = gql`
							query User(
								$state: String
								$limit: Int!
								$offset: Int
							) {
								viewer {
									pullRequests(
										state: $state
										limit: $limit
										offset: $offset
									) {
										id
										title
									}
								}
							}
						`
						
				</script></code></pre>

          <aside class="notes">
            - keyArgs define which arguments should be
            used to generate the cache key -
            relayStylePagination accepts them as an
            argument
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Final exercise time!
						Paginate results <!-- .element: class="subtitle" -->

						Actually display all loaded PR pages for all PR states.

						**Branch: `4-paginate-results-checkpoint-b`**
					</textarea
          >
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Field Policies</h2>
          <p class="subtitle">References</p>

          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|5-10|11-16|"><script type="text/template">
						const cache = new InMemoryCache({
							typePolicies: {
								User: {
									fields: {
										firstPR(_, { readField }) {
											const pullRequests = readField(
												"pullRequests"
											)
											return pullRequests[0] // { __ref: "PullRequest:123" }
										},
										firstPRTitle(_, { readField }) {
											const pullRequests = readField(
												"pullRequests"
											)
											return readField(pullRequests[0], "title")
										},
									},
								},
							},
						})
						
				</script></code></pre>

          <aside class="notes">
            - we can return a reference to another
            object from a read policy - we can also
            read fields from other objects in the cache
            instead of the parent by providing the
            reference - mention other read field
            arguments for working with references
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Field Policies</h2>
          <p class="subtitle">Cache Redirects</p>

          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|18-26|30-36|6-9|"><script type="text/template">
					const cache = new InMemoryCache({
						typePolicies: {
							Query: {
								fields: {
									pullRequest(_, { args, toReference }) {
										return toReference({
											__typename: 'PullRequest',
											id: args.id
										})
									},
								},
							},
						},
					});

					// query
					gql`
					query List {
						viewer {
							pullRequests {
								id
								title
								url
							}
						}
					}
					`

					gql`
					query Single($id: ID!) {
						pullRequest(id: $id) {
							id
							title
							url
						}
					}
					`
				</script></code></pre>

          <aside class="notes">
            - we can use field policies to improve
            caching for objects that we know are
            already in the cache but apollo doesn't
            recognize - we know that the second query
            will fetch the same data as the first, so
            we can use a cache redirect to avoid
            unnecessary network requests
          </aside>
        </section>

        <!---<section>
          <h2 data-id="code-title">Mocking</h2>
          <p class="subtitle">Introspection Query</p>
          <pre
            data-id="code-animation"
          ><code class="hljs graphql" data-trim data-line-numbers="|"><script type="text/template">
					query IntrospectionQuery {
						__schema {
							queryType { name }
							mutationType { name }
							subscriptionType { name }
							types {
								...FullType
							}
							directives {
								name
								description
								locations
								args {
									...InputValue
								}
							}
						}
					}
					fragment FullType on __Type {
						kind
						name
						description
						fields(includeDeprecated: true) {
							name
							description
							args {
								...InputValue
							}
							type {
								...TypeRef
							}
							isDeprecated
							deprecationReason
						}
						inputFields {
							...InputValue
						}
						interfaces {
							...TypeRef
						}
						enumValues(includeDeprecated: true) {
							name
							description
							isDeprecated
							deprecationReason
						}
						possibleTypes {
							...TypeRef
						}
					}
					fragment InputValue on __InputValue {
						name
						description
						type { ...TypeRef }
						defaultValue
					}
					fragment TypeRef on __Type {
						kind
						name
						ofType {
							kind
							name
							ofType {
								kind
								name
								ofType {
									kind
									name
									ofType {
										kind
										name
										ofType {
											kind
											name
											ofType {
												kind
												name
												ofType {
													kind
													name
												}
											}
										}
									}
								}
							}
						}
					}
				</script></code></pre>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Mocking</h2>
          <p class="subtitle">
            <code>@graphql-tools/mock</code>
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|2|5-8|"><script type="text/template">
					import { buildClientSchema } from "graphql"
					import * as introspectionResult from "schema.json"

					const schema = buildClientSchema(introspectionResult)
					const schemaWithMocks = addMocksToSchema({
						schema,
						mocks: {},
					})

				</script></code></pre>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Mocking</h2>
          <p>Type Mocks</p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|4-12|15-18|"><script type="text/template">
					import { buildClientSchema } from "graphql"
					import * as introspectionResult from "schema.json"

					const mocks = {
						Int: () => 6,
						Float: () => 22.1,
						String: () => "Hello",
						Person: () => ({
							name: random.name(),
							age: random.integer(0, 120),
						}),
					}

					const schema = buildClientSchema(introspectionResult)
					const schemaWithMocks = addMocksToSchema({
						schema,
						mocks,
					})
				</script></code></pre>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Mocking</h2>
          <p class="subtitle">
            Query and Mutation Results
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|24|5|6|6-8|9-11|4|13|14-18|"><script type="text/template">
					import { buildClientSchema } from "graphql"
					import * as introspectionResult from "schema.json"

					const resolvers = (store) => ({
						Query: {
							viewer(parent, args, context, info) {
								return JSON.parse(localStorage.getItem("user"))
							},
							userById(parent, { id }) {
								return store.get("User", id)
							},
						},
						Mutation: {
							changeMyName(parent, { name }) {
								store.set("Query", "ROOT", "viewer", { name })

								return store.get("Query", "ROOT", "viewer")
							},
						},
					})

					const schema = buildClientSchema(introspectionResult)
					const schemaWithMocks = addMocksToSchema({
						schema,
						mocks: {},
						resolvers,
					})
				</script></code></pre>
        </section>!-->
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <!-- <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/graphql.min.js"></script> -->

    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      const regex = {
        source(re) {
          if (!re) return null
          if (typeof re === "string") return re

          return re.source
        },

        concat(...args) {
          const joined = args
            .map((x) => regex.source(x))
            .join("")
          return joined
        },

        lookahead(re) {
          return regex.concat("(?=", re, ")")
        },
      }

      Reveal.initialize({
        highlight: {
          beforeHighlight: (hljs) =>
            hljs.registerLanguage(
              "graphql",
              function (hljs) {
                return {
                  name: "GraphQL",
                  aliases: ["gql"],
                  case_insensitive: !0,
                  disableAutodetect: !1,
                  keywords: {
                    keyword: [
                      "query",
                      "mutation",
                      "subscription",
                      "type",
                      "input",
                      "schema",
                      "directive",
                      "interface",
                      "union",
                      "scalar",
                      "fragment",
                      "enum",
                      "on",
                    ],
                    literal: ["true", "false", "null"],
                  },
                  contains: [
                    hljs.HASH_COMMENT_MODE,
                    hljs.QUOTE_STRING_MODE,
                    hljs.NUMBER_MODE,
                    {
                      scope: "punctuation",
                      match: /[.]{3}/,
                      relevance: 0,
                    },
                    {
                      scope: "punctuation",
                      begin:
                        /[\!\(\)\:\=\[\]\{\|\}]{1}/,
                      relevance: 0,
                    },
                    {
                      scope: "variable",
                      begin: /\$/,
                      end: /\W/,
                      excludeEnd: !0,
                      relevance: 0,
                    },
                    {
                      scope: "meta",
                      match: /@\w+/,
                      excludeEnd: !0,
                    },
                    {
                      scope: "symbol",
                      begin: regex.concat(
                        /[_A-Za-z][_0-9A-Za-z]*/,
                        regex.lookahead(/\s*:/)
                      ),
                      relevance: 0,
                    },
                  ],
                  illegal: [/[;<']/, /BEGIN/],
                }
              }
            ),
        },
        hash: true,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealNotes,
        ],

        // width: 960,
        // height: 600,

        // Factor of the display size that should remain empty around
        // the content
        margin: 0.04,
      })
    </script>
  </body>
</html>
