<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Apollo + React</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link
      rel="stylesheet"
      href="dist/theme/apollo.css"
    />

    <!-- Theme used for syntax highlighted code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/atom-one-dark.css"
    />
    <!-- <link rel="stylesheet" href="plugin/highlight/hybrid.css" /> -->

    <style>
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }

        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section
          data-background-image="https://d33wubrfki0l68.cloudfront.net/79880a56361cfde4c79207d6988a63495a3c1110/953fa/static/home-hero-ec83eaa910bbb42b62391e145e6c9a5f.png"
        >
          <h1 style="margin-bottom: 0">Apollo</h1>

          <p
            style="
              margin-top: 0;
              margin-bottom: calc(
                var(--r-block-margin) * 2
              );
              opacity: 0.6;
            "
          >
            Basics and Conventions
          </p>
          <div
            style="
              display: flex;
              justify-content: center;
            "
          >
            <svg
              width="100px"
              height="100px"
              viewBox="0 0 240 240"
              version="1.1"
              xmlns="http://www.w3.org/2000/svg"
              xmlns:xlink="http://www.w3.org/1999/xlink"
            >
              <g
                transform="translate(20.000000, 20.000000)"
                fill-rule="nonzero"
              >
                <polygon
                  fill="white"
                  points="112.4 48.7 88.2 48.7 53.2 139.6 75.1 139.6 80.8 124.2 113.9 124.2 107.9 107.2 86.1 107.2 100.3 68.1 125.5 139.6 147.4 139.6"
                ></polygon>
                <path
                  id="logo-spin"
                  fill="white"
                  d="M196.3,73 C196.2,72.7 196.2,72.4 196,72.1 C196,72 195.9,71.8 195.9,71.8 C195.1,70.1 193.4,68.9 191.4,68.9 C188.6,68.9 186.4,71.1 186.4,73.9 C186.4,74.5 186.5,75 186.7,75.5 L186.7,75.5 C188.9,83.4 190,91.6 190,100 C190,124 180.6,146.6 163.6,163.6 C146.6,180.6 124,190 100,190 C76,190 53.4,180.6 36.4,163.6 C19.4,146.6 10,124 10,100 C10,76 19.4,53.4 36.4,36.4 C53.4,19.4 76,10 100,10 C121.5,10 141.8,17.5 158,31.2 C157.5,32.6 157.2,34.1 157.2,35.7 C157.2,42.5 162.7,47.9 169.4,47.9 C176.2,47.9 181.6,42.4 181.6,35.7 C181.6,29 176.1,23.5 169.4,23.5 C167.9,23.5 166.5,23.8 165.2,24.2 C147.7,9.1 124.9,0 100,0 C44.8,0 0,44.8 0,100 C0,155.2 44.8,200 100,200 C155.2,200 200,155.2 200,100 C200,90.7 198.7,81.6 196.3,73 Z"
                  style="
                    transform-origin: 100px 100px;
                    animation: 2s
                      cubic-bezier(0.75, 0, 0.25, 1) 0s
                      infinite normal none running spin;
                  "
                ></path>
              </g>
              <rect
                fill="transparent"
                x="0"
                y="0"
                width="240"
                height="240"
              ></rect>
            </svg>
          </div>
        </section>

        <section data-markdown>
          <textarea data-template>
						## In the previous episode

						1. Queries and Mutations
						2. The GraphQL Document
						3. Interfaces and Unions
						4. Fragments
						5. Field Policies - Primer
					</textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
						## Coming up

						1. Pagination
						2. More field policies
						3. Mocking
						4. Network layer
					</textarea
          >
        </section>

        <section data-auto-animate>
          <h2>Rules</h2>

          <p>If you're stuck:</p>
          <ul>
            <li class="fragment">
              Please, avoid talking during exercises
              unless you're sure it will be useful to
              the entire group
            </li>
            <li class="fragment">
              Write a message on the
              <code>apollo-workshop</code> Slack
              channel with your code and I'll try to
              help
            </li>
            <li class="fragment">
              Check the solution branch for help
              (replace <code>template</code> with
              <code>solution</code> in the exercise
              branch name) e.g.
              <code>1-write-a-query-solution</code>
            </li>
          </ul>
        </section>

        <section data-auto-animate>
          <h2>Rules</h2>
          <p>To tell me you're ready to proceed:</p>
          <ul>
            <li class="fragment">
              For each exercise I'll add a message with
              it's number on Slack
            </li>
            <li class="fragment">
              React with ✅ to notify me that you're
              done
            </li>
          </ul>
        </section>

        <section>
          <h2 data-id="code-title">
            Basic Query Operation
          </h2>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|3|4|5|6|14|12-13|16|"><script type="text/template">
						import { gql, useQuery } from "@apollo/client"

						const Query = gql`
							query User {
								viewer {
									login
								}
							}
						`

						function Nav() {
							const {
								data: { viewer },
							} = useQuery(Query)

							return <nav>Hello ${viewer.login}</nav>
						}

					</script></code></pre>

          <aside class="notes">
            Quick recap of queries
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">
            Query Operations
          </h2>
          <p class="subtitle">Variables</p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|4|5|17|"><script type="text/template">
						import { gql, useQuery } from "@apollo/client"

						const Query = gql`
							query Repo($owner: String!, $name: String) {
								repository(owner: $owner, name: $name) {
									name
									url
								}
							}
						`

						function Repo({ owner, name }) {
							const {
								data: {
									repository,
								},
							} = useQuery(Query, { variables: { owner, name } })

							return (
								<div>
									{repository.name}
									{repository.url}
								</div>
							)
						}

					</script></code></pre>

          <aside class="notes">
            Quick recap of variables - must start with
            dollar sign
          </aside>
        </section>

        <section>
          <section data-auto-animate>
            <h2 data-id="code-title">
              Query Operations
            </h2>
            <p class="subtitle">State</p>
            <pre
              data-id="code-animation"
            ><code class="hljs jsx" data-trim data-line-numbers="|12-15"><script type="text/template">
							import { gql, useQuery } from "@apollo/client"
	
							const Query = gql`
								query User {
									viewer {
										login
									}
								}
							`
	
							function Nav() {
								const { loading, error, data } = useQuery(Query)
	
								if (loading) return "Loading…"
								if (error) return "Failed to load"
	
								return <nav>Hello ${data.viewer.login}</nav>
							}
	
										</script></code></pre>
            <aside class="notes">
              Quick recap of state
            </aside>
          </section>
          <section data-auto-animate>
            <h2 data-id="code-title">
              Query Operations
            </h2>
            <p class="subtitle">State Helpers</p>
            <pre><code class="hljs jsx" data-trim><script type="text/template">
							// api/graph/helpers.js
		
							const queryResultToStatus = ({
								loading,
								error,
								called,
								data,
							}) => {
								if (!called) return QueryStatus.Idle
								if (loading) return QueryStatus.Loading
								if (error) return QueryStatus.Error
								if (data) return QueryStatus.Success
								throw new Error(
									"Apollo query resulted in an unexpected state: ",
									{
										called,
										loading,
										error,
										data,
									}
								)
							}
							</script></code></pre>
            <aside class="notes">
              This is available - use it!
            </aside>
          </section>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Exercise time!
						Write a query <!-- .element: class="subtitle" -->

						Display the current user’s list of open pull requests.

						**Branch: `1-write-a-query-template`**

						----
						Don't worry about pagination at this stage, you can just display the 10 most recent pull requests.

						*Hint: Use the `viewer` field to access queries for the current user* <!-- .element: class="hint" -->

						Note:
						- Introduce Apollo Studio
						- Show the desired end result in the app
						- Apollo Studio query: MyOpenPullRequests

					</textarea
          >
        </section>

        <section>
          <h2 data-id="code-title">
            Basic Mutation Operation
          </h2>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|4|5-8|14|23|"><script type="text/template">
					import { gql, useMutation } from "@apollo/client"

					const StarRepoMutation = gql`
						mutation StarRepo($id: ID!) { 
							addStar(input: {starrableId: $id}) {
								starrable {
									stargazerCount
								}
							}
						}
					`

					function StarButton({ id }) {
						const [addStar, result] = useMutation(StarRepoMutation)
						const status = queryResultToStatus(result)

						if (status === QueryStatus.Loading) return "Loading…"
						if (status === QueryStatus.Error)
							return "Failed to load"

						return (
							<button
								onClick={() => addStar({ variables: { id } })}
							>
								⭐️
							</button>
						)
					}
					</script></code></pre>

          <aside class="notes">
            - Difference between useQuery and
            useMutation - Lazy execution of mutations -
            How to pass variables - How the cache is
            updated and why this won't display the most
            recent result
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">
            Anatomy of a GraphQL document
          </h2>
          <p class="subtitle">
            Defines one or more operations and
            fragments.
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs graphql" data-trim data-line-numbers=""><script type="text/template">
					{
						rateLimit {
							limit
							nodeCount
							remaining
						}
					}

					# or

					query {
						rateLimit {
							limit
							nodeCount
							remaining
						}
					}
				</script></code></pre>

          <aside class="notes">
            - The document is what is sent to the
            server - The default operation is a query
            (without the query keyword) - Only a single
            unnamed operation can be sent in a document
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">
            Anatomy of a GraphQL document
          </h2>
          <p class="subtitle">
            Defines one or more operations and
            fragments.
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs graphql" data-trim data-line-numbers=""><script type="text/template">
					query One {
						viewer {
							login
						}
						rateLimit {
							limit
							nodeCount
							remaining
						}
					}

					query Two {
						repository(owner: "apollographql", name: "apollo-client") {
							stargazers {
								totalCount
							}
						}
					}

					mutation StarRepo($id: ID!) { 
						addStar(input: {starrableId: $id}) {
							starrable {
								stargazerCount
							}
						}
					}
				</script></code></pre>

          <aside class="notes">
            - The document can contain multiple
            operations or fragments (query, mutation or
            subscription) - They must be named - The
            result is always a single object with the
            name of the operation as the key
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Exercise time!
						Write a mutation <!-- .element: class="subtitle" -->

						Convert a PR to a draft.
						* it should be marked as a draft **and**
						* the title should be prefixed with "I'M NOT DONE WITH THIS!"

						**Branch: `2-write-a-mutation-template`**

						----
						*Hint: Use the `convertPullRequestToDraft` mutation to convert to draft and the `updatePullRequest` mutation to update the title.* <!-- .element: class="hint" -->

						Note:
						- Show the desired result in the app
						- Show how to create a PR from Apollo Studio
						- Apollo Studio Query: ConvertPullRequestToDraf
					</textarea
          >
        </section>

        <section>
          <h2 data-id="code-title">
            Interfaces and Unions
          </h2>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|6-12|"><script type="text/template">
						import { gql, useMutation } from "@apollo/client"

						const StarRepoMutation = gql`
							mutation StarRepo($id: ID!) {
								addStar(input: { starrableId: $id }) {
									starrable {
										id
										stargazerCount
										... on Repository {
											homepageUrl
										}
									}
								}
							}
						`
						
						function StarButton({ id }) {
							const [addStar, result] = useMutation(StarRepoMutation)
							const status = queryResultToStatus(result)
						
							if (status === QueryStatus.Loading) return "Loading…"
							if (status === QueryStatus.Error)
								return "Failed to load"
						
							return (
								<button
									onClick={() => addStar({ variables: { id } })}
								>
									⭐️
								</button>
							)
						}
						
					</script></code></pre>

          <aside class="notes">
            - Interfaces are a way to describe the
            shape of a type - The implementing type
            must also include those fields - Showcase
            types in GraphQL schema - Apollo Studio
            Query: StarRepo
          </aside>
        </section>

        <section>
          <h2 data-id="code-title">Fragments</h2>
          <p class="subtitle">
            Share fields between operations
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|4-8|17|14|28|24|"><script type="text/template">
					import { gql, useQuery } from "@apollo/client"
					
					const ProfileFragment = gql`
						fragment Profile on User {
							id
							login
							avatarUrl
						}
					`
					
					const CurrentUserQuery = gql`
						query CurrentUser {
							viewer {
								...Profile
							}
						}
						${ProfileFragment}
					`
						
					const RepoOwnerQuery = gql`
						query Owner($name: String!, $owner: String!) {
							repository(name: $name, owner: $owner) {
								owner {
									...Profile
								}
							}
						}
						${ProfileFragment}
					`
				</script></code></pre>

          <aside class="notes">
            - Fragments are used to share fields
            between operations - They can also be
            defined on interfaces - showcase in AS -
            Apollo Studio Query: CurrentUser
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
					## Caching
					Apollo Normalized Cache <!-- .element: class="subtitle" -->
					- Responses are stored in a *local*, *normalized*, *in-memory* cache
					- Objects are identified by their `__typename` and `id` fields 

						(e.g. `Person:12345`)
					- Objects are stored in a *flat lookup table*

					Note:
					Showcase DevTools in OneRead
				</textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
					## Caching
					Cache Reads <!-- .element: class="subtitle" -->
					- If *all* requested data is present in the cache, that data is returned
					- This includes references to other objects
					- Otherwise, the request is sent to the server

					[Fetch Policies](https://www.apollographql.com/docs/react/data/queries/#setting-a-fetch-policy)

					Note:
					Describe different fetch policies and the default
				</textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
					## Caching
					Cache Writes <!-- .element: class="subtitle" -->
					- Objects in the cache are merged with new data.
					- For shared fields, the new object overwrites the cached values for those fields.
					- Other fields are preserved.
				</textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
					## Quiz Time!
				</textarea
          >
        </section>

        <section>
          <section data-auto-animate="">
            <p class="subtitle">
              Given the two queries below, what will be
              stored in the cache?
            </p>
            <pre
              data-id="code-animation"
              style="font-size: 0.26em"
            ><code class="hljs jsx" data-trim><script type="text/template">
											import { gql, useQuery } from "@apollo/client"
					
											const RepoQuery = gql`
												query Repo($name: String!, $owner: String!) {
													repository(name: $name, owner: $owner) {
														id
														url
														owner {
															... on Organization {
																id
																name
															}
														}
													}
												}
											`
					
											const OrgQuery = gql`
												query Org($login: String!) {
													organization(login: $login) {
														id
														name
														url
														avatarUrl
												}
											`
											
											function Component({ id }) {
												useQuery(RepoQuery, { variables: {name: "apollo", owner: "apollographql"}})
												useQuery(OrgQuery, { variables: {login: "apollographql"}})
											
												// ...
											}
											
									</script></code></pre>
          </section>
          <section data-auto-animate="">
            <p class="subtitle">
              Given the two queries below, what will be
              stored in the cache?
            </p>
            <div
              style="
                display: flex;
                flex-direction: row;
              "
            >
              <pre
                data-id="code-animation"
                style="font-size: 0.26em"
              ><code class="hljs jsx" data-trim><script type="text/template">
												import { gql, useQuery } from "@apollo/client"
					
												const RepoQuery = gql`
													query Repo($name: String!, $owner: String!) {
														repository(name: $name, owner: $owner) {
															id
															url
															owner {
																... on Organization {
																	id
																	name
																}
															}
														}
													}
												`
						
												const OrgQuery = gql`
													query Org($login: String!) {
														organization(login: $login) {
															id
															name
															url
															avatarUrl
													}
												`
												
												function Component({ id }) {
													useQuery(RepoQuery, { variables: {name: "apollo", owner: "apollographql"}})
													useQuery(OrgQuery, { variables: {login: "apollographql"}})
												
													// ...
												}
									</script></code></pre>
              <pre
                data-id="code-animation"
                style="
                  max-width: 350px;
                  padding-left: 8px;
                  font-size: 0.26em;
                "
              ><code class="hljs jsx" data-trim><script type="text/template">
									{
										"Repository:1": {
											"__typename": "Repository",
											"id": 1,
											"url": "https://github.com/apollographql/apollo-client",
											"owner": {
												"__ref": "Organization:1",
											}
										},
										"Organization:1": {
											"__typename": "Organization",
											"id: 1",
											"name": "apollographql",
											"url": "https://github.com/apollographql",
											"avatarUrl": "https://avatars.githubusercontent.com/u/17189275?s=200&v=4"
										}
									}
									</script></code></pre>
            </div>
          </section>
        </section>

        <section data-auto-animate="">
          <p class="subtitle">
            Will the second query's result be read from
            the cache or requested over the network?
          </p>

          <pre
            data-id="code-animation"
            style="font-size: 0.26em"
          ><code class="hljs jsx" data-trim><script type="text/template">
						import { gql, useQuery } from "@apollo/client"

						const RepoQuery = gql`
							query Repo($name: String!, $owner: String!) {
								repository(name: $name, owner: $owner) {
									id
									url
									owner {
										... on Organization {
											id
											name
										}
									}
								}
							}
						`

						const OrgQuery = gql`
							query Org($login: String!) {
								organization(login: $login) {
									id
									name
									url
									avatarUrl
							}
						`
						
						function Component({ id }) {
							useQuery(RepoQuery, { variables: {name: "apollo", owner: "apollographql"}})
							useQuery(OrgQuery, { variables: {login: "apollographql"}})
						
							// ...
						}
				</script></code></pre>
        </section>

        <section>
          <section data-auto-animate>
            <p
              class="subtitle"
              style="font-size: 0.6em"
            >
              What will be stored in the cache after
              the user clicks the button?
            </p>
            <img
              src="dist/assets/stars.png"
              height="30px"
              style="margin: 0"
            />
            <pre
              data-id="code-animation"
              style="font-size: 0.26em"
            ><code class="hljs jsx" data-trim><script type="text/template">
											import { gql, useQuery } from "@apollo/client"
					
											const RepoQuery = gql`
												query Repo($name: String!, $owner: String!) {
													repository(name: $name, owner: $owner) {
														id
														stargazerCount
													}
												}
											`
					
											const StarRepoMutation = gql`
												mutation StarRepo($id: ID!) {
													addStar(input: { starrableId: $id }) {
														starrable {
															... on Repository {
																homepageUrl
																stargazerCount
															}
														}
													}
												}
											`
											
											function StarButton() {
												const {data, loading, error} = useQuery(RepoQuery, { variables: {name: "apollo", owner: "apollographql"}})
												const [addStar, result] = useMutation(StarRepoMutation)
					
												if (loading) return "Loading…"
												if (error) return "Failed to load"
					
												return (
													<button
														onClick={() => addStar({ variables: { id: data.repository.id } })}
													>
														⭐️
													</button>
												)
											}		
											</script></code></pre>
          </section>
          <section data-auto-animate>
            <p
              class="subtitle"
              style="font-size: 0.6em"
            >
              What will be stored in the cache after
              the user clicks the button?
            </p>
            <img
              src="dist/assets/stars.png"
              height="30px"
              style="margin: 0"
            />
            <div
              style="
                display: flex;
                flex-direction: row;
              "
            >
              <pre
                data-id="code-animation"
                style="font-size: 0.26em"
              ><code class="hljs jsx" data-trim><script type="text/template">
											import { gql, useQuery } from "@apollo/client"
					
											const RepoQuery = gql`
												query Repo($name: String!, $owner: String!) {
													repository(name: $name, owner: $owner) {
														id
														stargazerCount
													}
												}
											`
					
											const StarRepoMutation = gql`
												mutation StarRepo($id: ID!) {
													addStar(input: { starrableId: $id }) {
														starrable {
															... on Repository {
																homepageUrl
																stargazerCount
															}
														}
													}
												}
											`
											
											function StarButton() {
												const {data, loading, error} = useQuery(RepoQuery, { variables: {name: "apollo", owner: "apollographql"}})
												const [addStar, result] = useMutation(StarRepoMutation)
					
												if (loading) return "Loading…"
												if (error) return "Failed to load"
					
												return (
													<button
														onClick={() => addStar({ variables: { id: data.repository.id } })}
													>
														⭐️
													</button>
												)
											}		
											</script></code></pre>
              <pre
                data-id="code-animation"
                style="
                  max-width: 350px;
                  padding-left: 8px;
                  font-size: 0.26em;
                "
              ><code class="hljs jsx" data-trim><script type="text/template">
											{
												"Repository:1": {
													"id": 1,
													"stargazerCount": 0
												}
											}
											</script></code></pre>
            </div>
          </section>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Field Policies
						* customize the way data is cached
						* customize the way data is read and written to the cache

						[API Reference](https://www.apollographql.com/docs/react/caching/cache-field-behavior#fieldpolicy-api-reference)

						Note:
						the field policy API provides a lot of tools to interact directly with the cache
					</textarea
          >
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Field Policies</h2>
          <p class="subtitle">
            Transform response fields
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|2|3-4|5|5-9|10-12|"><script type="text/template">
					const cache = new InMemoryCache({
						typePolicies: {
							User: {
								fields: {
									firstName: {
										read(value) {
											return value.toUpper()
										}
									},
									dateOfBirth(value) {
										return parseISO(value)
									},
								},
							},
						},
					});
				</script></code></pre>

          <aside class="notes">
            - map from __typenames to it's caching
            configuration - read is called whenever the
            field is read from the cache - shortcut
            when not defining anything else but the
            read function - the returned value will
            always be returned from requests regardless
            of fetch policy
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Field Policies</h2>
          <p class="subtitle">
            Calculate client-side data
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|5-10|22|"><script type="text/template">
					const cache = new InMemoryCache({
						typePolicies: {
							User: {
								fields: {
									age(_, { readField }) {
										return differenceInYears(
											new Date(),
											readField("dateOfBirth")
										)
									}
								},
							},
						},
					});

					// later in query
					const Query = gql`
						query User {
							viewer {
								login
								dateOfBirth
								age @client
							}
						}
					`
				</script></code></pre>

          <aside class="notes">
            - readField can be used to read fields from
            the cache that belong to the same parent
            object (the user in this case)
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Exercise time!
						Write a field policy <!-- .element: class="subtitle" -->

						Compute the complexity score for your PRs.

						**Branch: `3-write-a-field-policy-template`**

						----
						My score "formula" <!-- .element: class="hint" -->
						```js
const failurePenalty =
	headRef?.target?.status?.state === "FAILURE" ? 10 : 0

Math.floor(
	Math.abs(additions - deletions) / 100 +
		Math.pow(changedFiles, 2) / 100
) + failurePenalty
						```
						
						Feel free to use your own!

						Note:
						Showcase client schema after solution
					</textarea
          >
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Pagination</h2>
          <p class="subtitle">
            <code>fetchMore</code>
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|4|7-8|20-25|33-36|46-48|40-42|"><script type="text/template">
						import { gql, useQuery } from "@apollo/client"

						const OpenPullRequestsQuery = gql`
							query MyPullRequests($first: Int, $after: String) {
								viewer {
									pullRequests(
										first: $first, 
										after: $after, 
										states: [OPEN], 
										orderBy: { field: CREATED_AT, direction: DESC }) {
										edges {
											cursor # cursor for this node
											node {
												id
												title
												url
											}
										}

										pageInfo {
											hasNextPage
											hasPreviousPage
											startCursor # cursor for the first item in the page
											endCursor # cursor for the last item in the page
										}
								}
							}
						`

						const PAGE_SIZE = 10

						function Pagination() {
							const { data, fetchMore } = useQuery(
								OpenPullRequestsQuery,
								{ variables: { first: PAGE_SIZE } }
							)
							
							const pageInfo = data.viewer.pageInfo

							const onLoad = (cursor) => {
								fetchMore({ after: pageInfo.endCursor })
							}

							return (
								<div>
									{pageInfo.hasNextPage && (
										<button onClick={onLoad}>Next</button>
									)}
								</div>
							)
						}
				</script></code></pre>

          <aside class="notes">
            - when calling fetchMore you can provide
            new variables for the query - Apollo
            reexecutes this query
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Exercise time!
						Paginate results <!-- .element: class="subtitle" -->

						Use `fetchMore` to fetch the next page of PRs when clicking "Load More".

						**Branch: `4-paginate-results-template`**

						----
						Once the request is sent - is it updating the list? <!-- .element: class="hint" -->

						Note:
						- showcase tabs 
						- since queries are cached with all their arguments, this is just saved as a separate result in the cache
						- showcase in cache
						- it doesn't append to the previous query's result
						- we need to write a field policy that will merge the results
					</textarea
          >
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Field Policies</h2>
          <p class="subtitle">Update cache data</p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|5-10"><script type="text/template">
					const cache = new InMemoryCache({
						typePolicies: {
							User: {
								fields: {
									pullRequests: {
										merge(existing = [], incoming) {
											return [...existing, ...incoming];
										},
									},
								},
							},
						},
					});
				</script></code></pre>

          <aside class="notes">
            - merge is called whenever a field is
            updated in the cache - you can decide what
            ends up written to the cache based on the
            previous and new value
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Field Policies</h2>
          <p class="subtitle">
            Customize caching behavior
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|6|21-25|"><script type="text/template">
						const cache = new InMemoryCache({
							typePolicies: {
								User: {
									fields: {
										pullRequests: {
											keyArgs: ["states"],
										},
									},
								},
							},
						})
						
						// later in query
						const Query = gql`
							query User(
								$states: [String]
								$limit: Int!
								$offset: Int
							) {
								viewer {
									pullRequests(
										states: $states
										limit: $limit
										offset: $offset
									) {
										id
										title
									}
								}
							}
						`
						
				</script></code></pre>

          <aside class="notes">
            - keyArgs define which arguments should be
            used to generate the cache key -
            relayStylePagination accepts them as an
            argument
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Exercise time!
						Paginate results <!-- .element: class="subtitle" -->

						Display all loaded PR pages.

						**Branch: `4-paginate-results-checkpoint-a`**

						----
						*Hints* <!-- .element: class="hint" -->
						* write a merge policy <!-- .element: class="hint" -->
						* set appropriate <!-- .element: class="hint" --> `keyArgs` <!-- .element: class="hint" -->
					</textarea
          >
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Pagination</h2>
          <p class="subtitle">
            <code>relayStylePagination</code>
          </p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers=""><script type="text/template">
						const cache = new InMemoryCache({
							typePolicies: {
								User: {
									fields: {
										pullRequests: relayStylePagination("states")
									}
								}
							}
						})
				</script></code></pre>

          <aside class="notes">
            but Apollo provides us with a built-in
            policy for cursor pagination
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Final exercise time!
						Paginate results <!-- .element: class="subtitle" -->

						Use `relayStylePagination` to paginate pull requests.

						**Branch: `4-paginate-results-checkpoint-b`**
					</textarea
          >
        </section>

        <section>
          <section data-auto-animate="">
            <h2>Field Policies</h2>
            <p class="subtitle">Key Fields</p>
            <pre data-id="code-animation">
							<code class="hljs js" data-trim="" data-line-numbers="">
								<script type="text/template">
								const cache = new InMemoryCache({
									typePolicies: {
										User: {
											keyFields: ["login"],
										},
									},
								})</script>
							</code>
						</pre>
            <aside class="notes">
              - keyFields define which fields should be
              used to generate the cache key
            </aside>
          </section>
          <section data-auto-animate="">
            <h2>Field Policies</h2>
            <p class="subtitle">Key Fields</p>
            <pre data-id="code-animation">
							<code class="hljs js" data-trim="" data-line-numbers="">
								<script type="text/template">
								const cache = new InMemoryCache({
									typePolicies: {
										User: {
											keyFields: ["name", "email"],
										},
									},
								})</script>
							</code>
						</pre>
            <aside class="notes">
              multiple keyFields mean all the fields
              should be used to generate the cache key
            </aside>
          </section>
          <section data-auto-animate="">
            <h2>Field Policies</h2>
            <p class="subtitle">Key Fields</p>
            <pre data-id="code-animation">
							<code class="hljs js" data-trim="" data-line-numbers="">
								<script type="text/template">
								const cache = new InMemoryCache({
									typePolicies: {
										CurrentUser: {
											keyFields: [],
										},
									},
								})</script>
							</code>
						</pre>
            <aside class="notes">
              empty keyFields mean this type will
              always be a singleton - only one instance
              of it will ever be cached
            </aside>
          </section>
        </section>

        <section>
          <section data-auto-animate>
            <h2 data-id="code-title">
              Advanced Field Policies
            </h2>
            <p class="subtitle">References</p>
            <pre
              data-id="code-animation"
            ><code class="hljs jsx" data-trim data-line-numbers="|5-10|11-16|"><script type="text/template">
							const cache = new InMemoryCache({
								typePolicies: {
									User: {
										fields: {
											firstPR(_, { readField }) {
												const pullRequests = readField(
													"pullRequests"
												)
												return pullRequests[0] // { __ref: "PullRequest:123" }
											},
											firstPRTitle(_, { readField }) {
												const pullRequests = readField(
													"pullRequests"
												)
												return readField(pullRequests[0], "title")
											},
										},
									},
								},
							})
							</script></code></pre>
            <aside class="notes">
              - we can return a reference to another
              object from a read policy - we can also
              read fields from other objects in the
              cache instead of the parent by providing
              the reference
            </aside>
          </section>
          <section data-auto-animate>
            <h2 data-id="code-title">
              Advanced Field Policies
            </h2>
            <p class="subtitle">Cache Redirects</p>
            <pre
              data-id="code-animation"
            ><code class="hljs jsx" data-trim data-line-numbers="|18-26|30-36|6-9|"><script type="text/template">
										const cache = new InMemoryCache({
											typePolicies: {
												Query: {
													fields: {
														pullRequest(_, { args, toReference }) {
															return toReference({
																__typename: 'PullRequest',
																id: args.id
															})
														},
													},
												},
											},
										});
					
										// query
										gql`
										query List {
											viewer {
												pullRequests {
													id
													title
													url
												}
											}
										}
										`
					
										gql`
										query Single($id: ID!) {
											pullRequest(id: $id) {
												id
												title
												url
											}
										}
										`
									</script></code></pre>
            <aside class="notes">
              - we can use field policies to improve
              caching for objects that we know are
              already in the cache but apollo doesn't
              recognize - we know that the second query
              will fetch the same data as the first, so
              we can use a cache redirect to avoid
              unnecessary network requests
            </aside>
          </section>

          <section data-auto-animate>
            <h2 data-id="code-title">
              Advanced Field Policies
            </h2>
            <p class="subtitle">Other utilities</p>

            <a
              href="https://www.apollographql.com/docs/react/caching/cache-field-behavior#fieldpolicy-api-reference"
              >Full API Reference</a
            >
            <pre
              data-id="code-animation"
            ><code class="hljs jsx" data-trim data-line-numbers=""><script type="text/template">
							const cache = new InMemoryCache({
								typePolicies: {
									Query: {
										fields: {
											pullRequest: {
												read(existingValue, options) {
													const {
														cache,
														args,
														fieldName,
														field,
														variables,
														isReference,
														toReference,
														canRead,
														storage,
														mergeObjects,
													} = options
												},
											},
										},
									},
								},
							})
						</script></code></pre>

            <aside class="notes">
              - in the field policy options argument we
              get multiple low-level utilities for
              interacting directly with the cache
            </aside>
          </section>

          <section data-auto-animate>
            <h2 data-id="code-title">
              Advanced Field Policies
            </h2>
            <p class="subtitle">
              Arguments and variables
            </p>

            <pre
              data-id="code-animation"
            ><code class="hljs jsx" data-trim data-line-numbers=""><script type="text/template">
							useQuery(
								gql`
									query PullRequests($states: [String]) {
										viewer {
											pullRequests(
												states: $states
												orderBy: {
													field: CREATED_AT
													direction: DESC
												}
											) {
												id
												title
											}
										}
									}
								`,
								{ variables: { states: ["OPEN"] } }
							)

							const cache = new InMemoryCache({
								typePolicies: {
									User: {
										fields: {
											pullRequests: {
												read(_, options) {
													const { args, variables } = options

													variables
													/*
													{
														states: ['OPEN']
													}
													*/

													args
													/*
													{
														states: ['OPEN'],
														orderBy: {field": "CREATED_AT", "direction": "DESC"}
													}
													*/
												},
											},
										},
									},
								},
							})
						</script></code></pre>

            <aside class="notes">
              - arguments are all arguments passed to
              the field - variables are only the
              arguments that were provided dynamically
              to useQuery or useMutation
            </aside>
          </section>

          <section data-auto-animate>
            <h2 data-id="code-title">
              Advanced Field Policies
            </h2>
            <p class="subtitle">
              Working with references
            </p>

            <pre
              data-id="code-animation"
            ><code class="hljs jsx" data-trim data-line-numbers=""><script type="text/template">
							const cache = new InMemoryCache({
								typePolicies: {
									Query: {
										fields: {
											pullRequest: {
												read(_, options) {
													const {
														isReference,
														toReference,
														canRead,
														readField,
													} = options

													const ref = toReference({
														__typename: "PullRequest",
														id: "not-existing-id",
													})
													/*  
														{ 
															__ref: "PullRequest:non-existing-id" 
														}
													*/
													isReference(ref) // true
													canRead(ref) // false
													readField("title", ref) // undefined
												},
											},
										},
									},
								},
							})
						</script></code></pre>

            <aside class="notes">
              - canRead means that the reference points
              to an actual object in the cache
            </aside>
          </section>

          <section data-auto-animate>
            <h2 data-id="code-title">
              Advanced Field Policies
            </h2>
            <p class="subtitle">
              Interacting with the cache
            </p>

            <pre
              data-id="code-animation"
            ><code class="hljs jsx" data-trim data-line-numbers=""><script type="text/template">
							const PrQuery = gql`
								query PullRequest($id: ID!) {
									pullRequest(id: $id) {
										id
										title
									}
								}
							`

							const cache = new InMemoryCache({
								typePolicies: {
									Query: {
										fields: {
											pullRequest: {
												read(existingPr, options) {
													const { cache } = options

													cache.writeQuery({
														query: PrQuery,
														data: {
															__typename: "PullRequest",
															id: 1,
															title: "New title",
														},
													}) // update cache LOCALLY
													cache.readQuery({
														query: PrQuery,
														variables: { id: 1 },
													})
													cache.readFragment({
														id: "PullRequest:1",
														fragment: gql`
															fragment PRTitle on PullRequest {
																id
																title
															}
														`,
													})
													cache.writeFragment({
														id: "PullRequest:1",
														fragment: gql`
															fragment PRTitle on PullRequest {
																id
																title
															}
														`,
														data: { title: "Another title" },
													})

													cache.updateQuery(
														{ query: PrQuery },
														(data) => ({
															title: `${data.pullRequest.title}!!!`,
														})
													)

													const id = cache.identify(existingPr)
													cache.modify({
														id,
														fields: {
															title(existingTitle) {
																return existingTitle.toUpperCase()
															},
														},
													})
												},
											},
										},
									},
								},
							})
						</script></code></pre>

            <aside class="notes">
              cache.modify - doesn't call merge, has to
              write fields that already exist
            </aside>
          </section>

          <section data-auto-animate>
            <h2 data-id="code-title">
              Advanced Field Policies
            </h2>
            <p class="subtitle">Field cache</p>

            <pre
              data-id="code-animation"
            ><code class="hljs jsx" data-trim data-line-numbers=""><script type="text/template">
							const cache = new InMemoryCache({
								typePolicies: {
									Query: {
										fields: {
											pullRequest: {
												read(value, options) {
													const {
														fieldName, // "pullRequest"
														field, // internal metadata about this field
														storage, // persistent field-specific cache
													} = options

													const expensiveValue =
														storage["expensiveValue"] ||
														expensiveComputation(value)
												},
											},
										},
									},
								},
							})
						</script></code></pre>

            <aside class="notes"></aside>
          </section>

          <section data-auto-animate>
            <h2 data-id="code-title">
              Advanced Field Policies
            </h2>
            <p class="subtitle">Merge utilities</p>

            <pre
              data-id="code-animation"
            ><code class="hljs jsx" data-trim data-line-numbers=""><script type="text/template">
							const cache = new InMemoryCache({
								typePolicies: {
									PullRequest: {
										states: {
											merge(existing, incoming) {
												return [...existing, ...incoming]
											},
										},
									},

									Query: {
										fields: {
											pullRequest: {
												merge(existing, incoming, options) {
													const { mergeObjects } = options

													existing
													/* 
														{
															__typename: "PullRequest",
															id: 1,
															title: "A title",
															states: ["MERGED"]
														}
													*/

													incoming(
														/* 
														{
															__typename: "PullRequest",
															id: 1,
															title: "New title",
															states: ["OPEN"]
														}
													*/

														{ ...existing, ...incoming }
													)
													/* 
														{
															__typename: "PullRequest",
															id: 1,
															title: "New title",
															states: ["OPEN"]
														}
													*/

													mergeObjects(existing, incoming)
													/* 
														{
															__typename: "PullRequest",
															id: 1,
															title: "New title",
															states: ["MERGED", "OPEN"]
														}
													*/
												},
											},
										},
									},
								},
							})
						</script></code></pre>

            <aside class="notes"></aside>
          </section>
        </section>

        <section>
          <h2 data-id="code-title">Mocking</h2>
          <p class="subtitle">Introspection Query</p>
          <pre
            data-id="code-animation"
          ><code class="hljs graphql" data-trim data-line-numbers=""><script type="text/template">
					query IntrospectionQuery {
						__schema {
							queryType { name }
							mutationType { name }
							subscriptionType { name }
							types {
								...FullType
							}
							directives {
								name
								description
								locations
								args {
									...InputValue
								}
							}
						}
					}
					fragment FullType on __Type {
						kind
						name
						description
						fields(includeDeprecated: true) {
							name
							description
							args {
								...InputValue
							}
							type {
								...TypeRef
							}
							isDeprecated
							deprecationReason
						}
						inputFields {
							...InputValue
						}
						interfaces {
							...TypeRef
						}
						enumValues(includeDeprecated: true) {
							name
							description
							isDeprecated
							deprecationReason
						}
						possibleTypes {
							...TypeRef
						}
					}
					fragment InputValue on __InputValue {
						name
						description
						type { ...TypeRef }
						defaultValue
					}
					fragment TypeRef on __Type {
						kind
						name
						ofType {
							kind
							name
							ofType {
								kind
								name
								ofType {
									kind
									name
									ofType {
										kind
										name
										ofType {
											kind
											name
											ofType {
												kind
												name
												ofType {
													kind
													name
												}
											}
										}
									}
								}
							}
						}
					}
				</script></code></pre>

          <aside class="notes">
            this is used to get the full schema
            definition - every graphql server
            implements this query it is used to
            generate documentation in graphiql and to
            generate automated mocks
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Mocking</h2>
          <p class="subtitle">
            <code>@graphql-tools/mock</code>
          </p>
          <p class="subtitle">Executable Schema</p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|2|5-8|10-13|"><script type="text/template">
					import { buildClientSchema, graphql } from "graphql"
					import * as introspectionResult from "schema.json"

					const schema = buildClientSchema(introspectionResult)
					const schemaWithMocks = addMocksToSchema({
						schema,
						mocks: {},
					})

					graphql({
						schema,
						source: '{ viewer { login } }'
					})
				</script></code></pre>

          <aside class="notes">
            automatically generates mocks for built-in
            scalar types and object types based on the
            schema (pretty dumb)
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Mocking</h2>
          <p>Type Mocks</p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|5-7|8-11|15-18|"><script type="text/template">
					import { buildClientSchema } from "graphql"
					import * as introspectionResult from "schema.json"

					const mocks = {
						Int: () => 6,
						Float: () => 22.1,
						String: () => "Hello",
						Person: () => ({
							name: random.name(),
							age: random.integer(0, 120),
						}),
					}

					const schema = buildClientSchema(introspectionResult)
					const schemaWithMocks = addMocksToSchema({
						schema,
						mocks,
					})
				</script></code></pre>

          <aside class="notes">
            you can override how individual types are
            generated by providing a function for each
            type
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Mocking</h2>
          <p class="subtitle">Full Query Results</p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|5|6|7|16|"><script type="text/template">
					import { buildClientSchema } from "graphql"
					import * as introspectionResult from "schema.json"

					const resolvers = (store) => ({
						Query: {
							viewer(parent, args, context, info) {
								return JSON.parse(localStorage.getItem("user"))
							},
						},
					})

					const schema = buildClientSchema(introspectionResult)
					const schemaWithMocks = addMocksToSchema({
						schema,
						mocks: {},
						resolvers,
					})
				</script></code></pre>

          <aside class="notes">
            specific operation results and field values
            can also be mocked using resolvers
            resolvers can be dynamic, they have access
            to the parent object, the arguments,
            request context, and metadata about the
            graphql document
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Mocking</h2>
          <p class="subtitle">Using The Store</p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|12|14-16|5-9|"><script type="text/template">
					import { buildClientSchema } from "graphql"
					import * as introspectionResult from "schema.json"

					const mocks = {
						User: () => ({
							id: random.uuid(),
							name: random.name(),
							email: random.email()
						})
					}

					const resolvers = (store) => ({
						Query: {
							userById(parent, { id }) {
								return store.get("User", id)
							},
						},
					})

					const schema = buildClientSchema(introspectionResult)
					const schemaWithMocks = addMocksToSchema({
						schema,
						mocks,
						resolvers,
					})
				</script></code></pre>

          <aside class="notes">
            the mock server uses an underlying store to
            persist generated values it's similar to
            the apollo cache in this example we can
            force it to use the provided id argument by
            using the store.get function - it will
            return the value from the store if it
            exists, otherwise it will generate a new
            value but use the provided id
          </aside>
        </section>

        <section data-auto-animate>
          <h2 data-id="code-title">Mocking</h2>
          <p class="subtitle">Mutation Results</p>
          <pre
            data-id="code-animation"
          ><code class="hljs jsx" data-trim data-line-numbers="|5|7|9|"><script type="text/template">
					import { buildClientSchema } from "graphql"
					import * as introspectionResult from "schema.json"

					const resolvers = (store) => ({
						Mutation: {
							changeMyName(parent, { name }) {
								store.set("Query", "ROOT", "viewer", { name })

								return store.get("Query", "ROOT", "viewer")
							},
						},
					})

					const schema = buildClientSchema(introspectionResult)
					const schemaWithMocks = addMocksToSchema({
						schema,
						mocks: {},
						resolvers,
					})
				</script></code></pre>

          <aside class="notes">
            similarly, you can update the store with
            the results of a mutation and return the
            updated result
          </aside>
        </section>

        <section data-markdown>
          <textarea data-template>
						## Exercise time!
						Mock GitHub API <!-- .element: class="subtitle" -->

						Make the app work with a mock GitHub API.

						**Branch: `5-mock-responses-template`**

						----

						*You will need to provide mocks for some scalars used by GitHub* <!-- .element: class="hint" -->
					</textarea
          >
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <!-- <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/graphql.min.js"></script> -->

    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      const regex = {
        source(re) {
          if (!re) return null
          if (typeof re === "string") return re

          return re.source
        },

        concat(...args) {
          const joined = args
            .map((x) => regex.source(x))
            .join("")
          return joined
        },

        lookahead(re) {
          return regex.concat("(?=", re, ")")
        },
      }

      Reveal.initialize({
        highlight: {
          beforeHighlight: (hljs) =>
            hljs.registerLanguage(
              "graphql",
              function (hljs) {
                return {
                  name: "GraphQL",
                  aliases: ["gql"],
                  case_insensitive: !0,
                  disableAutodetect: !1,
                  keywords: {
                    keyword: [
                      "query",
                      "mutation",
                      "subscription",
                      "type",
                      "input",
                      "schema",
                      "directive",
                      "interface",
                      "union",
                      "scalar",
                      "fragment",
                      "enum",
                      "on",
                    ],
                    literal: ["true", "false", "null"],
                  },
                  contains: [
                    hljs.HASH_COMMENT_MODE,
                    hljs.QUOTE_STRING_MODE,
                    hljs.NUMBER_MODE,
                    {
                      scope: "punctuation",
                      match: /[.]{3}/,
                      relevance: 0,
                    },
                    {
                      scope: "punctuation",
                      begin:
                        /[\!\(\)\:\=\[\]\{\|\}]{1}/,
                      relevance: 0,
                    },
                    {
                      scope: "variable",
                      begin: /\$/,
                      end: /\W/,
                      excludeEnd: !0,
                      relevance: 0,
                    },
                    {
                      scope: "meta",
                      match: /@\w+/,
                      excludeEnd: !0,
                    },
                    {
                      scope: "symbol",
                      begin: regex.concat(
                        /[_A-Za-z][_0-9A-Za-z]*/,
                        regex.lookahead(/\s*:/)
                      ),
                      relevance: 0,
                    },
                  ],
                  illegal: [/[;<']/, /BEGIN/],
                }
              }
            ),
        },
        hash: true,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealNotes,
        ],

        // width: 960,
        // height: 600,

        // Factor of the display size that should remain empty around
        // the content
        margin: 0.04,
      })
    </script>
  </body>
</html>
